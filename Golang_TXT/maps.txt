// d == dicionário
definition, ok := d[word]

// d[word] retorna o valor associado à chave, se houver, e opcionalmente retorna um segundo valor, true se o lookup deu certo, false otherwise


var m map[string]int  
// map string->int, m == nil. Não pode escrever nele ainda, senão dá erro!


m = make(map[string]int)
// m agora pointer pra hash table (string->int)
// por default, m['whatever'] == 0


// esse aqui embaixo vai ser equivalente a esse uso do make em cima
m = map[string]int{}

m["route"] = 66  // "route" -> 66
m["towel"] = 42


i := m["route"]
// declarada 'i', iniciada com valor 66


j := m["root"]
// j == 0.
// Por default, tentar acessar key não declarada retorna o 'zero value' do tipo, que pra int é 0


n := len(m)
// len(m) retorna o número de keys declaradas no map


delete(m, "route")
// delete (mapVar, "key") deleta "key" do map.
// A função não retorna nada, e não fará nada se a key não existir.


i, ok := m["route"]
// 'i' recebe o valor guardado pela key 'route'
// se a key não existe, i == type's zero value
// ok == true se a key existe, false otherwise.


for key, value := range m {
    fmt.Println("Key: ", key, "Value: ", value)
}


karutaClub := map[string]int{
    "chihaya": 0,
    "taichi": 1,
    "kana": 2,
    "desktomu": 3,
    "nishida": 4,
}



// Percorre uma lista de Nodes e imprime os valores.
// Para se um ciclo for detectado na lista.
    type Node struct {
        Next  *Node
        Value interface{}
    }
    var first *Node

    visited := make(map[*Node]bool)
    for n := first; n != nil; n = n.Next {
        if visited[n] {
            fmt.Println("cycle detected")
            break
        }
        visited[n] = true
        fmt.Println(n.Value)
    }